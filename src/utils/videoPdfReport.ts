import jsPDF from 'jspdf';
import 'jspdf-autotable';
import type {
  VideoRepAnalysisResult,
  RepAnalysisResult,
  VideoExerciseType,
} from '@/types/video';

export interface VideoPdfReportOptions {
  language: 'ko' | 'en';
  includeScreenshots: boolean;
  includeRecommendations: boolean;
}

export interface ProblemMomentCapture {
  timestamp: number;
  repNumber: number;
  score: number;
  feedbacks: string[];
  screenshotDataUrl?: string;
}

export interface VideoPdfReportData {
  exerciseType: VideoExerciseType;
  repAnalysis: VideoRepAnalysisResult;
  problemMomentCaptures: ProblemMomentCapture[];
}

const EXERCISE_LABELS: Record<VideoExerciseType, { ko: string; en: string }> = {
  squat: { ko: '스쿼트', en: 'Squat' },
  lunge: { ko: '런지', en: 'Lunge' },
  deadlift: { ko: '데드리프트', en: 'Deadlift' },
  pushup: { ko: '푸시업', en: 'Push-up' },
  plank: { ko: '플랭크', en: 'Plank' },
  unknown: { ko: '운동', en: 'Exercise' },
};

// Extend jsPDF type to include autoTable
interface jsPDFWithAutoTable extends jsPDF {
  autoTable: (options: {
    head: string[][];
    body: string[][];
    startY: number;
    margin: { left: number; right: number };
    headStyles: {
      fillColor: [number, number, number];
      textColor: [number, number, number];
      fontStyle: string;
    };
    alternateRowStyles: { fillColor: [number, number, number] };
    styles: {
      textColor: [number, number, number];
      fillColor: [number, number, number];
      fontSize: number;
    };
  }) => void;
  lastAutoTable: { finalY: number };
}

export class VideoPdfReportGenerator {
  private doc: jsPDFWithAutoTable;
  private language: 'ko' | 'en';
  private yPosition: number = 20;
  private pageWidth: number;
  private margin: number = 20;
  private options: VideoPdfReportOptions;

  private colors = {
    primary: [0, 245, 160] as [number, number, number],
    secondary: [0, 221, 255] as [number, number, number],
    background: [17, 24, 39] as [number, number, number],
    text: [255, 255, 255] as [number, number, number],
    textSecondary: [156, 163, 175] as [number, number, number],
    statusGood: [0, 245, 160] as [number, number, number],
    statusWarning: [255, 184, 0] as [number, number, number],
    statusError: [255, 61, 113] as [number, number, number],
    screenshotBorder: [31, 41, 55] as [number, number, number],
    timestampBadge: [55, 65, 81] as [number, number, number],
    scoreExcellent: [0, 245, 160] as [number, number, number],
    scoreGood: [0, 221, 255] as [number, number, number],
    scoreWarning: [255, 184, 0] as [number, number, number],
    scorePoor: [255, 61, 113] as [number, number, number],
  };

  private translations = {
    ko: {
      title: '비디오 분석 리포트',
      overallScore: '전체 점수',
      summary: '요약',
      totalReps: '총 반복 횟수',
      avgScore: '평균 점수',
      bestRep: '최고 반복',
      worstRep: '최저 반복',
      perRepBreakdown: '반복별 분석',
      repNumber: '반복 #',
      score: '점수',
      duration: '시간',
      issues: '이슈',
      recommendations: '개선 권장사항',
      footer: 'PostureAI 비디오 분석 시스템으로 생성됨',
      problemMoments: '문제 순간 스크린샷',
      repLabel: '반복',
      timestampLabel: '시간',
      scoreLabel: '점수',
      feedbackLabel: '피드백',
      noScreenshots: '캡처된 스크린샷이 없습니다',
    },
    en: {
      title: 'Video Analysis Report',
      overallScore: 'Overall Score',
      summary: 'Summary',
      totalReps: 'Total Reps',
      avgScore: 'Average Score',
      bestRep: 'Best Rep',
      worstRep: 'Worst Rep',
      perRepBreakdown: 'Per-Rep Breakdown',
      repNumber: 'Rep #',
      score: 'Score',
      duration: 'Duration',
      issues: 'Issues',
      recommendations: 'Recommendations',
      footer: 'Generated by PostureAI Video Analysis System',
      problemMoments: 'Problem Moment Screenshots',
      repLabel: 'Rep',
      timestampLabel: 'Time',
      scoreLabel: 'Score',
      feedbackLabel: 'Feedback',
      noScreenshots: 'No screenshots captured',
    },
  };

  constructor(options: VideoPdfReportOptions) {
    this.doc = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
    }) as jsPDFWithAutoTable;
    this.options = options;
    this.language = options.language;
    this.pageWidth = this.doc.internal.pageSize.getWidth();
  }

  async generateReport(data: VideoPdfReportData): Promise<Blob> {
    const { repAnalysis, problemMomentCaptures } = data;

    // 1. Header
    this.addHeader(data.exerciseType);

    // 2. Overall Score
    this.addOverallScore(repAnalysis.summary.averageScore);

    // 3. Summary Stats
    this.addSummaryStats(repAnalysis);

    // 4. Per-Rep Table
    this.addRepTable(repAnalysis.reps);

    // 5. Recommendations
    if (this.options.includeRecommendations) {
      this.addRecommendations(repAnalysis);
    }

    // 6. Screenshots Section
    if (this.options.includeScreenshots && problemMomentCaptures.length > 0) {
      this.addScreenshotsSection(problemMomentCaptures);
    }

    // 7. Footer
    this.addFooter();

    return this.doc.output('blob');
  }

  private addHeader(exerciseType: VideoExerciseType): void {
    const t = this.translations[this.language];
    const exerciseLabel = EXERCISE_LABELS[exerciseType][this.language];

    // Title
    this.doc.setFontSize(24);
    this.doc.setTextColor(...this.colors.primary);
    this.doc.text(t.title, this.margin, this.yPosition);
    this.yPosition += 10;

    // Exercise type
    this.doc.setFontSize(14);
    this.doc.setTextColor(...this.colors.textSecondary);
    this.doc.text(exerciseLabel, this.margin, this.yPosition);
    this.yPosition += 8;

    // Date
    const dateStr = new Date().toLocaleDateString(
      this.language === 'ko' ? 'ko-KR' : 'en-US',
      { year: 'numeric', month: 'long', day: 'numeric' }
    );
    this.doc.setFontSize(10);
    this.doc.text(dateStr, this.margin, this.yPosition);
    this.yPosition += 15;

    // Divider
    this.doc.setDrawColor(...this.colors.primary);
    this.doc.setLineWidth(0.5);
    this.doc.line(
      this.margin,
      this.yPosition,
      this.pageWidth - this.margin,
      this.yPosition
    );
    this.yPosition += 10;
  }

  private addOverallScore(score: number): void {
    const t = this.translations[this.language];
    const scoreColor =
      score >= 80
        ? this.colors.statusGood
        : score >= 60
          ? this.colors.statusWarning
          : this.colors.statusError;

    // Section title
    this.doc.setFontSize(14);
    this.doc.setTextColor(...this.colors.primary);
    this.doc.text(t.overallScore, this.margin, this.yPosition);
    this.yPosition += 8;

    // Large score
    this.doc.setFontSize(48);
    this.doc.setTextColor(...scoreColor);
    this.doc.text(`${score}`, this.pageWidth / 2, this.yPosition, {
      align: 'center',
    });
    this.yPosition += 20;
  }

  private addSummaryStats(repAnalysis: VideoRepAnalysisResult): void {
    const t = this.translations[this.language];

    this.doc.setFontSize(14);
    this.doc.setTextColor(...this.colors.primary);
    this.doc.text(t.summary, this.margin, this.yPosition);
    this.yPosition += 8;

    const stats = [
      [t.totalReps, repAnalysis.totalReps.toString()],
      [t.avgScore, `${repAnalysis.summary.averageScore}/100`],
      [
        t.bestRep,
        `#${repAnalysis.consistency.bestRep} (${repAnalysis.summary.maxScore})`,
      ],
      [
        t.worstRep,
        `#${repAnalysis.consistency.worstRep} (${repAnalysis.summary.minScore})`,
      ],
    ];

    this.doc.setFontSize(11);
    this.doc.setTextColor(...this.colors.text);

    stats.forEach(([label, value]) => {
      this.doc.text(`${label}: ${value}`, this.margin, this.yPosition);
      this.yPosition += 6;
    });

    this.yPosition += 8;
  }

  private addRepTable(reps: RepAnalysisResult[]): void {
    const t = this.translations[this.language];

    this.doc.setFontSize(14);
    this.doc.setTextColor(...this.colors.primary);
    this.doc.text(t.perRepBreakdown, this.margin, this.yPosition);
    this.yPosition += 8;

    const headers = [[t.repNumber, t.score, t.duration, t.issues]];
    const data = reps.map((rep) => [
      `#${rep.repNumber}`,
      rep.score.toString(),
      `${(rep.duration / 1000).toFixed(1)}s`,
      rep.primaryIssues.slice(0, 2).join(', ') || '-',
    ]);

    this.doc.autoTable({
      head: headers,
      body: data,
      startY: this.yPosition,
      margin: { left: this.margin, right: this.margin },
      headStyles: {
        fillColor: this.colors.primary,
        textColor: this.colors.background,
        fontStyle: 'bold',
      },
      alternateRowStyles: {
        fillColor: [31, 41, 55],
      },
      styles: {
        textColor: [200, 200, 200],
        fillColor: [17, 24, 39],
        fontSize: 9,
      },
    });

    this.yPosition = this.doc.lastAutoTable.finalY + 10;
  }

  private addRecommendations(repAnalysis: VideoRepAnalysisResult): void {
    const t = this.translations[this.language];

    // Aggregate all issues across reps
    const issueCounts: Record<string, number> = {};
    repAnalysis.reps.forEach((rep) => {
      rep.primaryIssues.forEach((issue) => {
        issueCounts[issue] = (issueCounts[issue] || 0) + 1;
      });
    });

    // Sort by frequency
    const sortedIssues = Object.entries(issueCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5);

    if (sortedIssues.length === 0) return;

    this.doc.setFontSize(14);
    this.doc.setTextColor(...this.colors.primary);
    this.doc.text(t.recommendations, this.margin, this.yPosition);
    this.yPosition += 8;

    this.doc.setFontSize(10);
    this.doc.setTextColor(...this.colors.text);

    sortedIssues.forEach(([issue, count], index) => {
      const text = `${index + 1}. ${issue} (${count}x)`;
      this.doc.text(text, this.margin, this.yPosition, {
        maxWidth: this.pageWidth - this.margin * 2,
      });
      this.yPosition += 8;
    });
  }

  private addFooter(): void {
    const t = this.translations[this.language];
    const pageHeight = this.doc.internal.pageSize.getHeight();

    this.doc.setFontSize(8);
    this.doc.setTextColor(...this.colors.textSecondary);
    this.doc.text(t.footer, this.margin, pageHeight - 10);
    this.doc.text(
      new Date().toISOString(),
      this.pageWidth - this.margin - 50,
      pageHeight - 10
    );
  }

  private addScreenshotsSection(problemMoments: ProblemMomentCapture[]): void {
    const t = this.translations[this.language];
    const pageHeight = this.doc.internal.pageSize.getHeight();

    // Section title
    this.doc.setFontSize(14);
    this.doc.setTextColor(...this.colors.primary);
    this.doc.text(t.problemMoments, this.margin, this.yPosition);
    this.yPosition += 10;

    if (problemMoments.length === 0) {
      this.doc.setFontSize(10);
      this.doc.setTextColor(...this.colors.textSecondary);
      this.doc.text(t.noScreenshots, this.margin, this.yPosition);
      this.yPosition += 10;
      return;
    }

    const imageWidth = 80; // mm
    const blockHeight = 60; // estimated height per block

    for (const moment of problemMoments) {
      // Check page overflow
      if (this.yPosition + blockHeight > pageHeight - 30) {
        this.doc.addPage();
        this.yPosition = 20;
      }

      // Add screenshot block
      this.addScreenshotBlock(moment, imageWidth);
      this.yPosition += 15; // spacing between blocks
    }
  }

  private addScreenshotBlock(moment: ProblemMomentCapture, imageWidth: number): void {
    const t = this.translations[this.language];
    const startY = this.yPosition;

    // Calculate image height based on 4:3 aspect ratio (default assumption)
    const imageHeight = (imageWidth * 3) / 4;

    // Draw screenshot if available
    if (moment.screenshotDataUrl) {
      try {
        this.doc.addImage(
          moment.screenshotDataUrl,
          'JPEG',
          this.margin,
          this.yPosition,
          imageWidth,
          imageHeight
        );

        // Draw border around image
        this.doc.setDrawColor(...this.colors.screenshotBorder);
        this.doc.setLineWidth(0.5);
        this.doc.rect(this.margin, this.yPosition, imageWidth, imageHeight);
      } catch {
        // If image fails to load, continue without it
        console.warn('Failed to add screenshot image to PDF');
      }
    }

    // Info panel - positioned to the right of the image
    const infoPanelX = this.margin + imageWidth + 8;
    let infoPanelY = startY;

    // Rep badge
    this.doc.setFillColor(...this.colors.timestampBadge);
    this.doc.roundedRect(infoPanelX, infoPanelY, 25, 7, 1, 1, 'F');
    this.doc.setFontSize(9);
    this.doc.setTextColor(...this.colors.text);
    this.doc.text(`${t.repLabel} #${moment.repNumber}`, infoPanelX + 2, infoPanelY + 5);
    infoPanelY += 10;

    // Timestamp badge
    this.doc.setFillColor(...this.colors.timestampBadge);
    this.doc.roundedRect(infoPanelX, infoPanelY, 30, 7, 1, 1, 'F');
    this.doc.setFontSize(9);
    this.doc.setTextColor(...this.colors.text);
    this.doc.text(this.formatTimestamp(moment.timestamp), infoPanelX + 2, infoPanelY + 5);
    infoPanelY += 10;

    // Score badge with color based on thresholds
    const scoreColor = this.getScoreColor(moment.score);
    this.doc.setFillColor(...scoreColor);
    this.doc.roundedRect(infoPanelX, infoPanelY, 25, 7, 1, 1, 'F');
    this.doc.setFontSize(9);
    this.doc.setTextColor(...this.colors.background);
    this.doc.text(`${t.scoreLabel}: ${moment.score}`, infoPanelX + 2, infoPanelY + 5);
    infoPanelY += 12;

    // Feedback list
    if (moment.feedbacks && moment.feedbacks.length > 0) {
      this.doc.setFontSize(9);
      this.doc.setTextColor(...this.colors.textSecondary);
      this.doc.text(`${t.feedbackLabel}:`, infoPanelX, infoPanelY);
      infoPanelY += 5;

      // Show max 3 feedbacks
      const feedbacksToShow = moment.feedbacks.slice(0, 3);
      for (const feedback of feedbacksToShow) {
        this.doc.setFontSize(8);
        this.doc.setTextColor(...this.colors.textSecondary);
        // Truncate long feedback
        const maxLength = 35;
        const truncatedFeedback = feedback.length > maxLength
          ? feedback.substring(0, maxLength - 3) + '...'
          : feedback;
        this.doc.text(`• ${truncatedFeedback}`, infoPanelX, infoPanelY);
        infoPanelY += 4;
      }

      // Indicate if more feedbacks exist
      if (moment.feedbacks.length > 3) {
        this.doc.text(`... +${moment.feedbacks.length - 3} more`, infoPanelX, infoPanelY);
        infoPanelY += 4;
      }
    }

    // Update yPosition to the bottom of the block
    this.yPosition = Math.max(startY + imageHeight, infoPanelY) + 5;
  }

  private getScoreColor(score: number): [number, number, number] {
    if (score >= 90) return this.colors.scoreExcellent;
    if (score >= 75) return this.colors.scoreGood;
    if (score >= 60) return this.colors.scoreWarning;
    return this.colors.scorePoor;
  }

  private formatTimestamp(ms: number): string {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    const milliseconds = ms % 1000;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
  }
}
